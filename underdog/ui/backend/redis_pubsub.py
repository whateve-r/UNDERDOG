"""
REDIS PUB/SUB - EVENT BACKBONE
================================================
Async Redis Pub/Sub messaging layer for decoupling
trading strategies from UI components.

Architecture:
    Strategies ‚Üí publish ‚Üí Redis ‚Üí subscribe ‚Üí FastAPI ‚Üí WebSocket ‚Üí Dash

Channels:
    - trade:signal - New trading signals generated
    - trade:execution - Order fills/rejections
    - metrics:pnl - Real-time P&L updates
    - metrics:dd - Drawdown threshold alerts
    - market:tick - High-frequency market data (optional)
    - command:control - Bidirectional control commands

Author: UNDERDOG Team
Version: 1.0.0
"""

import asyncio
import json
import logging
from datetime import datetime
from typing import Any, Callable, Dict, List, Optional
from dataclasses import dataclass, asdict

try:
    import redis.asyncio as aioredis  # aioredis>=2.0 uses redis.asyncio
except ImportError:
    import aioredis  # Fallback for older versions

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


# ======================== EVENT SCHEMAS ========================

@dataclass
class TradeSignalEvent:
    """Trading signal generated by an EA"""
    ea_name: str
    symbol: str
    type: str  # "BUY" or "SELL"
    entry_price: float
    sl: float
    tp: float
    volume: float
    confidence: float
    timestamp: int
    
    def to_json(self) -> str:
        return json.dumps(asdict(self))
    
    @classmethod
    def from_json(cls, data: str) -> 'TradeSignalEvent':
        return cls(**json.loads(data))


@dataclass
class OrderExecutionEvent:
    """Order execution result"""
    ea_name: str
    symbol: str
    ticket: int
    type: str
    volume: float
    entry_price: float
    sl: float
    tp: float
    status: str  # "FILLED", "REJECTED", "PARTIAL"
    slippage_pips: float
    commission: float
    timestamp: int
    
    def to_json(self) -> str:
        return json.dumps(asdict(self))
    
    @classmethod
    def from_json(cls, data: str) -> 'OrderExecutionEvent':
        return cls(**json.loads(data))


@dataclass
class MetricsPnLEvent:
    """Real-time P&L metrics"""
    account_balance: float
    equity: float
    daily_pnl: float
    daily_dd: float
    total_dd: float
    floating_dd: float
    sharpe_ratio: float
    calmar_ratio: float
    win_rate: float
    open_positions: int
    timestamp: int
    
    def to_json(self) -> str:
        return json.dumps(asdict(self))
    
    @classmethod
    def from_json(cls, data: str) -> 'MetricsPnLEvent':
        return cls(**json.loads(data))


@dataclass
class DrawdownAlertEvent:
    """Drawdown threshold breach alert"""
    alert_type: str  # "DAILY", "TOTAL", "FLOATING"
    current_value: float
    threshold: float
    severity: str  # "WARNING", "CRITICAL"
    timestamp: int
    
    def to_json(self) -> str:
        return json.dumps(asdict(self))
    
    @classmethod
    def from_json(cls, data: str) -> 'DrawdownAlertEvent':
        return cls(**json.loads(data))


# ======================== REDIS PUB/SUB MANAGER ========================

class RedisPubSubManager:
    """
    High-performance async Redis Pub/Sub manager.
    
    Features:
        - Automatic reconnection
        - Pattern-based subscriptions
        - Callback registration
        - Health monitoring
    """
    
    def __init__(
        self,
        redis_url: str = "redis://localhost:6379",
        max_retries: int = 5,
        retry_delay: float = 2.0
    ):
        self.redis_url = redis_url
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        
        self.redis: Optional[aioredis.Redis] = None
        self.pubsub: Optional[aioredis.client.PubSub] = None
        self.callbacks: Dict[str, List[Callable]] = {}
        self.running = False
        
    async def connect(self):
        """Establish Redis connection with retry logic"""
        for attempt in range(self.max_retries):
            try:
                self.redis = await aioredis.from_url(
                    self.redis_url,
                    encoding="utf-8",
                    decode_responses=True
                )
                await self.redis.ping()
                logger.info(f"‚úÖ Connected to Redis at {self.redis_url}")
                return
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Redis connection attempt {attempt + 1}/{self.max_retries} failed: {e}")
                if attempt < self.max_retries - 1:
                    await asyncio.sleep(self.retry_delay)
                else:
                    raise ConnectionError(f"Failed to connect to Redis after {self.max_retries} attempts")
    
    async def disconnect(self):
        """Gracefully close Redis connection"""
        if self.pubsub:
            await self.pubsub.unsubscribe()
            await self.pubsub.close()
        if self.redis:
            await self.redis.close()
        logger.info("‚ùå Disconnected from Redis")
    
    async def publish(self, channel: str, message: str):
        """
        Publish message to a channel.
        
        Args:
            channel: Redis channel name
            message: JSON-serialized message
        """
        if not self.redis:
            raise RuntimeError("Redis not connected. Call connect() first.")
        
        try:
            await self.redis.publish(channel, message)
            logger.debug(f"üì§ Published to {channel}: {message[:100]}...")
        except Exception as e:
            logger.error(f"‚ùå Failed to publish to {channel}: {e}")
            raise
    
    def register_callback(self, channel: str, callback: Callable):
        """
        Register a callback function for a specific channel.
        
        Args:
            channel: Redis channel name (supports patterns like 'trade:*')
            callback: Async function to call when message received
        """
        if channel not in self.callbacks:
            self.callbacks[channel] = []
        self.callbacks[channel].append(callback)
        logger.info(f"‚úÖ Registered callback for channel: {channel}")
    
    async def subscribe(self, *channels: str):
        """
        Subscribe to one or more channels.
        
        Args:
            *channels: Channel names to subscribe to
        """
        if not self.redis:
            raise RuntimeError("Redis not connected. Call connect() first.")
        
        self.pubsub = self.redis.pubsub()
        await self.pubsub.subscribe(*channels)
        logger.info(f"‚úÖ Subscribed to channels: {', '.join(channels)}")
    
    async def subscribe_pattern(self, *patterns: str):
        """
        Subscribe to channels matching patterns.
        
        Args:
            *patterns: Pattern strings (e.g., 'trade:*', 'metrics:*')
        """
        if not self.redis:
            raise RuntimeError("Redis not connected. Call connect() first.")
        
        self.pubsub = self.redis.pubsub()
        await self.pubsub.psubscribe(*patterns)
        logger.info(f"‚úÖ Subscribed to patterns: {', '.join(patterns)}")
    
    async def listen(self):
        """
        Listen for messages and dispatch to callbacks.
        
        This is the main event loop that processes incoming messages.
        """
        if not self.pubsub:
            raise RuntimeError("Not subscribed to any channels. Call subscribe() first.")
        
        self.running = True
        logger.info("üéß Listening for messages...")
        
        try:
            async for message in self.pubsub.listen():
                if message["type"] in ("message", "pmessage"):
                    channel = message["channel"]
                    data = message["data"]
                    
                    logger.debug(f"üì• Received from {channel}: {data[:100]}...")
                    
                    # Dispatch to registered callbacks
                    for pattern, callbacks in self.callbacks.items():
                        if self._channel_matches_pattern(channel, pattern):
                            for callback in callbacks:
                                try:
                                    await callback(channel, data)
                                except Exception as e:
                                    logger.error(f"‚ùå Callback error for {channel}: {e}")
        except asyncio.CancelledError:
            logger.info("üõë Listen loop cancelled")
            self.running = False
        except Exception as e:
            logger.error(f"‚ùå Listen loop error: {e}")
            self.running = False
            raise
    
    def _channel_matches_pattern(self, channel: str, pattern: str) -> bool:
        """Check if channel matches pattern (supports '*' wildcard)"""
        if '*' not in pattern:
            return channel == pattern
        
        # Simple wildcard matching
        pattern_parts = pattern.split('*')
        if len(pattern_parts) == 2:
            prefix, suffix = pattern_parts
            return channel.startswith(prefix) and channel.endswith(suffix)
        return False


# ======================== HELPER FUNCTIONS ========================

async def publish_trade_signal(
    manager: RedisPubSubManager,
    signal: TradeSignalEvent
):
    """Publish a trade signal event"""
    await manager.publish("trade:signal", signal.to_json())


async def publish_order_execution(
    manager: RedisPubSubManager,
    execution: OrderExecutionEvent
):
    """Publish an order execution event"""
    await manager.publish("trade:execution", execution.to_json())


async def publish_pnl_metrics(
    manager: RedisPubSubManager,
    metrics: MetricsPnLEvent
):
    """Publish P&L metrics"""
    await manager.publish("metrics:pnl", metrics.to_json())


async def publish_dd_alert(
    manager: RedisPubSubManager,
    alert: DrawdownAlertEvent
):
    """Publish drawdown alert"""
    await manager.publish("metrics:dd", alert.to_json())


# ======================== EXAMPLE USAGE ========================

async def example_usage():
    """
    Example demonstrating Publisher and Subscriber patterns.
    """
    # Create manager
    manager = RedisPubSubManager()
    await manager.connect()
    
    # Register callback
    async def handle_signal(channel: str, data: str):
        signal = TradeSignalEvent.from_json(data)
        logger.info(f"üéØ Signal Received: {signal.ea_name} {signal.type} {signal.symbol} @ {signal.entry_price}")
    
    manager.register_callback("trade:signal", handle_signal)
    
    # Subscribe
    await manager.subscribe("trade:signal", "metrics:pnl")
    
    # Start listening in background
    listen_task = asyncio.create_task(manager.listen())
    
    # Simulate publishing
    signal = TradeSignalEvent(
        ea_name="SuperTrendRSI",
        symbol="EURUSD",
        type="BUY",
        entry_price=1.10250,
        sl=1.10100,
        tp=1.10400,
        volume=0.05,
        confidence=0.95,
        timestamp=int(datetime.now().timestamp() * 1000)
    )
    await publish_trade_signal(manager, signal)
    
    # Wait a bit
    await asyncio.sleep(2)
    
    # Cleanup
    listen_task.cancel()
    await manager.disconnect()


if __name__ == "__main__":
    asyncio.run(example_usage())
